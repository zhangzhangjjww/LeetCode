Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”

        _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2       0       8
         /  \
         7   4
For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.



It's recursive and expands the meaning of the function. If the current (sub)tree contains both p and q, then the function result is their LCA. If only one of them is in that subtree, then the result is that one of them. If neither are in that subtree, the result is null/None/nil.


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        //发现目标节点则通过返回值标记该子树发现了某个目标结点
        if (!root || root == p || root == q) return root; 
        //查看左子树中是否有目标结点，没有为null
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        //查看右子树是否有目标节点，没有为null
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        //都不为空，说明左右子树都有目标结点，则公共祖先就是本身  
        if(left!=NULL&&right!=NULL) {
            return root;
        }
        else {
            //如果发现了目标节点，则继续向上标记为该目标节点
            return left?left:right;
        }
    }
    
};
